#!/usr/bin/env node

// naive example using the GH CLI would be simpler in a real pipeline.

import { readFileSync, existsSync } from 'fs';
import { execSync } from 'child_process';

interface PRData {
  title: string;
  body: string;
  base: string;
  head: string;
}

class PRManager {
  private githubToken: string;
  private repoOwner: string;
  private repoName: string;

  constructor() {
    this.githubToken = process.env.GITHUB_TOKEN || '';
    this.repoOwner = process.env.GITHUB_REPOSITORY_OWNER || '';
    this.repoName = process.env.GITHUB_REPOSITORY?.split('/')[1] || '';
    
    if (!this.githubToken) {
      throw new Error('GITHUB_TOKEN environment variable is required');
    }
  }

  async createResearchPR(): Promise<void> {
    console.log('üîÄ Creating research pull request...');

    const prData = await this.preparePRData();
    
    const prCommand = `gh pr create --title "${prData.title}" --body "${prData.body}" --base ${prData.base} --head ${prData.head}`;
    
    try {
      const result = execSync(prCommand, { 
        encoding: 'utf-8',
        env: { ...process.env, GITHUB_TOKEN: this.githubToken }
      });
      console.log('‚úÖ Pull request created successfully!');
      console.log(result);
    } catch (error) {
      console.error('‚ùå Failed to create pull request:', error);
      throw error;
    }
  }

  private async preparePRData(): Promise<PRData> {
    const branchName = `research-${new Date().toISOString().split('T')[0]}`;
    
    // Create and switch to new branch
    try {
      execSync(`git checkout -b ${branchName}`, { encoding: 'utf-8' });
    } catch (error) {
      // Branch might already exist
      execSync(`git checkout ${branchName}`, { encoding: 'utf-8' });
    }

    const title = `Research Update: ${new Date().toLocaleDateString()}`;
    
    let body = `# Research Update\n\n`;
    
    // Add research findings if available
    if (existsSync('RESEARCH.md')) {
      const researchContent = readFileSync('RESEARCH.md', 'utf-8');
      body += `## Research Findings\n\n${researchContent}\n\n`;
    }
    
    // Add synthesis if available
    if (existsSync('SYNTHESIS.md')) {
      const synthesisContent = readFileSync('SYNTHESIS.md', 'utf-8');
      body += `## Synthesis Report\n\n${synthesisContent}\n\n`;
    }
    
    body += `## Changes Made\n\n`;
    body += `- Updated research findings\n`;
    body += `- Generated synthesis report\n`;
    body += `- Automated research workflow execution\n\n`;
    
    body += `## Next Steps\n\n`;
    body += `- Review research findings\n`;
    body += `- Discuss synthesis recommendations\n`;
    body += `- Plan next research phase\n\n`;
    
    body += `---\n*This PR was automatically generated by the AI Research System*`;

    return {
      title,
      body,
      base: 'main',
      head: branchName
    };
  }

  async commitAndPushChanges(): Promise<void> {
    console.log('üíæ Committing and pushing changes...');
    
    try {
      // Add all changes
      execSync('git add .', { encoding: 'utf-8' });
      
      // Commit changes
      const commitMessage = `Research update: ${new Date().toISOString()}`;
      execSync(`git commit -m "${commitMessage}"`, { encoding: 'utf-8' });
      
      // Push to remote
      const currentBranch = execSync('git branch --show-current', { encoding: 'utf-8' }).trim();
      execSync(`git push origin ${currentBranch}`, { encoding: 'utf-8' });
      
      console.log('‚úÖ Changes committed and pushed successfully!');
    } catch (error) {
      console.error('‚ùå Failed to commit and push changes:', error);
      throw error;
    }
  }
}

// Main execution
async function main() {
  try {
    const prManager = new PRManager();
    
    // First commit and push changes
    await prManager.commitAndPushChanges();
    
    // Then create the pull request
    await prManager.createResearchPR();
    
    console.log('üéâ PR workflow completed successfully!');
  } catch (error) {
    console.error('‚ùå PR creation failed:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

export { PRManager };
